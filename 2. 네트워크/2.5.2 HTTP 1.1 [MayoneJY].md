## 🔹 HTTP/1.1 이란?

HTTP/1.1은 1997년 RFC 2068(이후 RFC 2616으로 개정)에서 정의된 프로토콜로, HTTP/1.0의 한계를 개선한 버전입니다.
가장 중요한 변화는 Keep-Alive 기능의 표준화입니다.

## 🔹 Keep-Alive 표준화

- HTTP/1.0에서는 Connection: keep-alive 헤더를 통해 연결을 재사용할 수 있었지만 비표준 확장에 불과했습니다.

- HTTP/1.1에서는 Persistent Connection이 기본값으로 적용되어, 하나의 TCP 연결에서 여러 요청/응답을 주고받을 수 있게 되었습니다.

- 이를 통해 매 요청마다 TCP 3-Way Handshake를 반복하지 않아도 되므로, RTT 절약과 성능 향상이 가능했습니다.

## 🔹 HTTP/1.0 vs HTTP/1.1 비교
| 구분         | HTTP/1.0             | HTTP/1.1                        |
| ---------- | -------------------- | ------------------------------- |
| **TCP 연결** | 매 요청마다 새 연결 생성       | Persistent Connection (기본)      |
| **헤더**     | 간단하지만 확장성 부족         | Host 헤더 필수, 기능 확장 가능            |
| **파이프라이닝** | 미지원                  | 지원 (단, HOL Blocking 문제 존재)      |
| **캐싱 제어**  | 단순 If-Modified-Since | ETag, Cache-Control 등 세분화       |
| **에러 처리**  | 제한적 상태 코드            | 100 Continue, 409 Conflict 등 확장 |
| **성능**     | RTT 증가 심각            | RTT 감소, 성능 개선                   |

## 🔹 HOL Blocking (Head-of-Line Blocking)

- 파이프라이닝(Pipelining) 기능을 통해 하나의 연결에서 여러 요청을 연속적으로 보낼 수 있었음.

- 하지만 응답은 순차적으로 도착해야 했기 때문에 앞선 요청의 응답이 지연되면 뒤 요청들이 모두 대기하게 되는 문제가 발생 → 이것을 HOL Blocking이라 함.

- 이 문제는 HTTP/2의 Multiplexing으로 해결됨.

## 🔹 무거운 헤더 구조

- HTTP/1.1은 여전히 텍스트 기반 프로토콜로, 요청마다 반복되는 헤더 정보(예: Cookie, User-Agent, Host 등) 가 계속 전송됨.

- 특히 쿠키가 커지면 요청 패킷이 불필요하게 비대해져 대역폭 낭비와 성능 저하로 이어짐.

- 이 문제는 HTTP/2의 **Header Compression (HPACK)**으로 개선됨.

## 🔹 예상 면접 질문 & 답변
### 1. HTTP/1.1에서 가장 중요한 개선점은 무엇인가요?

답변: 

가장 중요한 변화는 Persistent Connection을 기본으로 지원했다는 점입니다. HTTP/1.0은 요청마다 TCP 연결을 맺어야 해서 RTT가 크게 발생했지만, 1.1에서는 한 번 연결하면 여러 요청과 응답을 처리할 수 있어 성능이 개선되었습니다.

### 2. HTTP/1.0과 HTTP/1.1의 차이를 간단히 설명해보세요.

답변:

- 연결 관리: 1.0은 매 요청마다 새 연결, 1.1은 Persistent Connection 기본.

- 헤더: 1.1은 Host 헤더 필수, 캐싱 제어 기능 확장.

- 성능: 1.1은 파이프라이닝 지원, RTT 감소.

- 단점: HOL Blocking 문제와 무거운 헤더 구조는 여전히 존재.

### 3. HTTP/1.1의 HOL Blocking 문제는 무엇인가요?

답변: 

파이프라이닝으로 여러 요청을 보낼 수 있지만, 응답은 순서대로 도착해야 했습니다. 따라서 앞선 요청의 응답이 지연되면 뒤 요청들도 대기하게 됩니다. 이를 HOL Blocking이라고 합니다. 이 문제는 HTTP/2의 Multiplexing으로 해결되었습니다.

### 4. HTTP/1.1의 헤더 구조 문제는 왜 성능 저하로 이어지나요?

답변: 

HTTP/1.1은 텍스트 기반이라 매 요청마다 반복적으로 큰 헤더(쿠키, User-Agent 등)가 포함됩니다. 특히 쿠키가 클 경우 전송 데이터 양이 불필요하게 증가해 대역폭 낭비와 지연을 유발합니다. 이 문제는 HTTP/2에서 HPACK 압축으로 해결되었습니다.