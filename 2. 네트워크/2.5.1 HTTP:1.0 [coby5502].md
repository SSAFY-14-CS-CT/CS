# 2.5.1 HTTP/1.0

## **핵심 특징 (RFC 1945, 1996)**

- **요청 1개 = 연결 1개(비지속 연결)**
    
    기본 동작은 요청을 처리하면 **TCP 연결을 바로 끊음**.
    
- **Host 헤더가 기본이 아님**
    
    가상호스팅 지원이 제한적(같은 IP에서 다수 도메인 서비스가 어려움).
    
- **캐시/압축/지속연결은 제한적**
    
    일부는 사실상 “관행적 확장”으로 쓰였고(예: Connection: keep-alive), 표준화·호환성은 좋지 않았음.
    

## **왜 RTT가 커질까?**

TCP는 연결을 만들 때 **3-웨이 핸드셰이크(3-way handshake)**가 필요하고, 전송 자체도 왕복 지연이 누적됨.

### **요청 1건에 드는 대략의 시간 흐름(간단화)**

```
① TCP 핸드셰이크   : 1 RTT
② 요청 전송/첫 바이트 수신(TTFB) : ~1 RTT (+ 서버 처리 시간)
③ 컨텐츠 수신(혼잡제어/슬로우 스타트 영향)
```

HTTP/1.0은 **리소스마다 연결을 새로 맺기** 때문에,

이미지 20개면 핸드셰이크·슬로우스타트를 20번 반복 → **RTT 누적 + TCP 오버헤드 폭증**.

---

# **RTT 증가를 줄이려 했던 고전적 최적화**

> 주의: 아래 기법은
> 
> 
> **HTTP/2/3 시대엔 대부분 이점이 줄거나 오히려 역효과**
> 
> **HTTP/1.0/1.1 전성기**
> 

## **1) 이미지 스프라이트(Image Spriting)**

여러 아이콘/스몰 이미지를 **한 장의 큰 이미지**에 모으고, CSS로 좌표를 잘라 표시.

```
/* 하나의 큰 스프라이트 시트에서 각 아이콘 영역만 보여준다 */
.icon {
  background-image: url('/img/sprite.png');
  background-repeat: no-repeat;
  display:inline-block;
}
.icon-search { width:16px; height:16px; background-position:-32px -16px; }
.icon-user   { width:16px; height:16px; background-position:-48px -16px; }
```

- **장점**
    - HTTP 요청 수 급감 → **핸드셰이크/RTT 절약**.
    - 작은 아이콘 다수일수록 효과 큼.
- **단점**
    - **부분 캐시 불가**: 아이콘 하나만 바뀌어도 스프라이트 전체 재배포/재다운로드.
    - 초기 다운로드가 커짐, 레티나/다크모드/반응형 대응 복잡.
- **언제 유리?**
    - HTTP/1.0·1.1 환경, 작은 아이콘이 매우 많고 변경이 드문 경우.

## **2) 코드 압축(Minification) & 번들링(Bundling)**

JS/CSS/HTML에서 공백·개행·주석 제거, 식별자 축약, 파일 개수 줄이기.

- **장점**
    - **바이트 수 감소**(전송시간·대역폭 절약), **요청 수도 감소**(번들링 시).
- **단점**
    - 디버깅 어려움 → **소스맵** 필수.
    - 거대한 번들은 **HTTP/2/3** 환경에서 오히려 캐시/병렬성에 불리.
- **현대 권장**
    - **Minify는 항상 좋음**(브로틀리/gzip과 함께).
    - 번들링은 **적당히**(라우트·기능 단위 코드스플리팅).

## **3) 이미지 Base64 인코딩(Data URL)**

이미지를 **문자열로 인코딩**해 HTML/CSS에 직접 삽입(추가 요청 제거).

```
<img
  alt="logo"
  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA..."
/>
```

- **장점**
    - 리소스 **요청 수 0** (해당 이미지에 대해선 추가 RTT 없음).
    - 소수의 아주 작은 이미지(수백 바이트~1KB대)에서 간편.
- **단점**
    - **용량 증가(약 +33%)**: Base64는 4/3 팽창.
    - **개별 캐시 불가**: HTML/CSS 바뀌면 **이미지도 다시 다운로드**.
    - 메모리/파서 부하, 이미지 재사용성↓.
- **언제 유리?**
    - **아주 작은 아이콘**(파비콘 변형, inlined SVG 등) 정도.
    - 큰 이미지/빈번 변경 리소스엔 **비추**.

---

# **HTTP/1.0에서 자주 쓰던 추가 팁**

## **A. (확장) Keep-Alive로 연결 재사용 시도**

HTTP/1.0 기본은 비지속이지만, 서버/클라이언트가 합의하면 다음처럼 **연결 유지**를 시도:

```
Request:
GET /style.css HTTP/1.0
Connection: keep-alive

Response:
HTTP/1.0 200 OK
Connection: keep-alive
Content-Length: 1234
...
```

- **효과**: 같은 연결로 **여러 리소스 연속 요청** → 핸드셰이크·슬로우스타트 비용 절감.
- **주의**: 당대 프록시/서버 간 **호환성 이슈**가 잦았고, **표준은 HTTP/1.1**에서 확립됨.

## **B. 압축 전송(Content-Encoding)**

텍스트 리소스(HTML/CSS/JS/JSON)에 **gzip/deflate** 압축을 적용.

- **효과**: 전송 바이트↓ → 시간↓. (이미지는 자체 포맷이 압축이므로 별도 압축 X)
- **현대**: 가능하면 **Brotli(br)** 우선, 그 다음 gzip.

## **C. 캐싱 헤더**

- **HTTP/1.0**: Expires, (사실상 확장으로) If-Modified-Since
- **HTTP/1.1**: Cache-Control, ETag, Last-Modified 등 체계화
    
    → **강력 캐시 + 조건부 요청**으로 불필요 재다운로드 제거.
    

---

# **용어 정리 (핵심만 콕)**

- **RTT (Round-Trip Time)**: 패킷이 **왕복**하는 데 걸리는 시간. 지연(latency)의 핵심 지표.
- **3-웨이 핸드셰이크**: TCP 연결 수립 절차(SYN → SYN/ACK → ACK).
- **TCP 슬로우 스타트**: 혼잡제어의 일환. 새 연결은 작은 윈도로 시작해 **점진적으로 전송량 증가**.
- **비지속 연결(Non-persistent)**: 요청마다 TCP를 새로 맺고 끊는 모드(HTTP/1.0 기본).
- **지속 연결(Persistent/Keep-Alive)**: 하나의 TCP 연결로 여러 요청/응답 처리.
- **데이터 URL(Base64)**: data:[mime];base64,.... 형태로 **리소스를 문서에 인라인 삽입**.
- **스프라이트(Sprite)**: **여러 이미지를 한 장**으로 묶고 CSS 좌표로 잘라 쓰는 기법.
- **Minify**: 공백/주석 제거 등으로 텍스트 리소스 **최소화**.

---

# **요즘(HTTP/2/3) 기준으로 한 줄 가이드**

- **Minify + Brotli/Gzip**: 여전히 **강력 추천**.
- **스프라이트/대규모 번들/대량 Base64**: 대체로 **지양**(HTTP/2 멀티플렉싱, 개별 캐시 이점이 더 큼).
- **리소스 힌트**: preconnect, dns-prefetch, preload로 초기 지연 최적화.
- **이미지**: 포맷(WebP/AVIF), 크기 조정, srcset/sizes, 캐시·CDN 정책으로 최적화.

---

# **한눈에 정리**

- HTTP/1.0은 **요청마다 TCP 연결**을 새로 맺어 **RTT/슬로우스타트 비용**이 큼.
- 이를 줄이려 **요청 수 감소(스프라이트, 번들, Base64)** 와 **바이트 감소(Minify/압축)** 를 적용.
- 현대 스택에선 **Minify/압축/캐시**는 계속 유효, **요청-감소 트릭(스프라이트·대규모 Base64 등)** 은 **신중하게**.

---

# ✅ HTTP/1.0 정리 (면접 대비)

## 📌 특징

- **요청 1개 = TCP 연결 1개 (비지속 연결)**
- 매 리소스 요청마다 **TCP 3-Way Handshake** → RTT 지연 증가
- 캐싱/호스트 지정 등 기능이 제한적
    
    (예: `Host` 헤더가 표준이 아님 → 같은 IP에서 다수 도메인 서비스 어려움)
    

---

## 📌 단점

- **RTT 증가**: 리소스가 많을수록 핸드셰이크/슬로우 스타트 반복
- **리소스 낭비**: 연결 수립·종료 오버헤드 큼
- **확장성 부족**: 멀티 도메인, 캐싱 정책 제한적

---

## 📌 RTT (Round-Trip Time)

- 패킷이 출발지 → 목적지 → 출발지로 돌아오기까지의 시간
- TCP 연결 수립, 요청-응답 지연, 혼잡 제어 등에서 중요한 성능 지표

---

## 📌 HTTP/1.0 성능 최적화 방법들 (당시 관행)

1. **이미지 스프라이트**
    
    여러 아이콘 → 하나의 큰 이미지에 모음 → CSS 좌표로 잘라 쓰기
    
    ➡️ 요청 수 줄임 (핸드셰이크 절약)
    
2. **코드 압축(Minify)**
    
    JS/CSS/HTML의 공백, 주석 제거 → 바이트 수 절감
    
    ➡️ 전송 지연 감소
    
3. **Base64 인코딩**
    
    작은 이미지를 HTML/CSS에 인라인 삽입 → 추가 요청 제거
    
    ➡️ 요청 수 ↓, 하지만 크기는 약 33% 증가
    
4. **(확장) Keep-Alive 옵션**
    
    `Connection: keep-alive` 헤더로 여러 요청을 하나의 TCP 연결에서 처리
    
    ➡️ RTT 절감, 하지만 호환성 이슈 있음
    

---

## 📌 이후 버전 개선

- **HTTP/1.1**: 기본 지속 연결(Persistent Connection), `Host` 헤더 필수, 캐싱/파이프라이닝 지원
- **HTTP/2**: 멀티플렉싱(한 연결로 여러 요청 병렬 처리), 헤더 압축, 서버 푸시
- **HTTP/3(QUIC)**: UDP 기반, 0-RTT 핸드셰이크, 지연 최소화

---

# ✅ 면접 꼬리 질문 예시

### Q1. **HTTP/1.0에서 RTT가 늘어나는 이유는 무엇인가요?**

👉 요청마다 새로운 TCP 연결을 맺어야 하기 때문입니다.

각 연결은 3-Way Handshake와 TCP 슬로우 스타트 과정을 거치므로 왕복 지연(RTT)이 누적됩니다.

---

### Q2. **이 RTT 문제를 어떻게 줄일 수 있었나요?**

👉 요청 수 자체를 줄이는 방식이 주로 쓰였습니다.

예를 들어,

- 이미지 스프라이트(여러 아이콘을 한 장으로 합침)
- 코드 압축/번들링(파일 개수 줄이기)
- Base64 인코딩(아주 작은 이미지를 HTML/CSS에 인라인 삽입)
    
    그리고 `Connection: keep-alive` 옵션으로 연결을 재사용하는 방법도 있었습니다.
    

---

### Q3. **Base64 인코딩의 단점은 뭔가요?**

👉 전송 크기가 약 33% 증가합니다.

또한 HTML/CSS 문서가 변경되면 이미지도 함께 다시 다운로드해야 하므로 **캐시 효율성이 떨어집니다**.

---

### Q4. **왜 이미지 스프라이트는 HTTP/2/3에서는 잘 안 쓰이나요?**

👉 HTTP/2부터는 멀티플렉싱 덕분에 **요청 수가 많아도 병렬 처리 가능**합니다.

따라서 굳이 큰 이미지를 묶어 캐시 효율을 떨어뜨릴 필요가 없습니다.

---

### Q5. **HTTP/1.0과 HTTP/1.1 차이는 무엇인가요?**

👉 HTTP/1.1은

- 기본적으로 **지속 연결**을 지원
- `Host` 헤더 필수 → 가상 호스팅 가능
- 캐시 제어(`Cache-Control`, `ETag`) 강화
- 파이프라이닝 지원 등으로 성능과 확장성이 크게 개선되었습니다.

---

### Q6. **RTT를 줄이는 더 근본적인 방식은 무엇일까요?**

👉 전송 계층 개선입니다.

HTTP/3는 UDP 기반 QUIC을 사용하여 0-RTT 핸드셰이크를 지원, 연결 설정 지연을 크게 줄였습니다.

---

# ✅ 한눈에 요약

- HTTP/1.0: **비지속 연결** → 요청마다 TCP 핸드셰이크 → **RTT 증가**
- 해결책: 요청 수 줄이기 (스프라이트, Minify, Base64), Keep-Alive
- 한계: 편법적, 유지보수·캐시 비효율
- 진화: HTTP/1.1(지속 연결), HTTP/2(멀티플렉싱), HTTP/3(0-RTT, UDP)