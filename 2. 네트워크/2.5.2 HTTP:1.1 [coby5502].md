# 2.5.2 HTTP/1.1

## ✅ 특징

- **Persistent Connection (Keep-Alive)**
    - HTTP/1.0과 달리 매 요청마다 새로운 TCP 연결을 맺지 않고, 한 번 맺은 TCP 연결을 유지(persistent connection)하여 여러 요청/응답을 처리할 수 있음.
    - TCP 3-웨이 핸드셰이크 오버헤드를 줄여 성능 개선.
- **단점: 요청 순차 처리**
    - 같은 연결에서 여러 요청을 보낼 수 있지만, 응답은 순서대로 처리해야 함.
    - 문서 안에 이미지, CSS, JS 등 여러 리소스가 포함되면 요청 개수에 비례해 **대기 시간이 길어짐**.

---

## ✅ 문제점

### 1. HOL Blocking (Head of Line Blocking)

- **정의**: 큐(Queue)에서 맨 앞 패킷이 지연되면 뒤의 패킷도 함께 지연되는 현상.
- **HTTP/1.1에서 발생하는 이유**:
    - 파이프라이닝(pipelining)을 지원하지만, 응답은 순서대로 와야 하므로 앞선 요청이 지연되면 뒤의 요청도 대기해야 함.
    - 예: HTML을 먼저 받고 이미지 요청을 보냈는데, HTML 응답이 늦어지면 이미지도 지연됨.

### 2. 무거운 헤더 구조

- 요청 시마다 **쿠키, User-Agent, Authorization 등 메타데이터**가 매번 반복 전송됨.
- 헤더에 압축 기능이 없어 **불필요하게 크고 비효율적**.
- 모바일/저대역폭 환경에서는 큰 병목이 됨.

---

## ✅ 해결하려는 시도

- 브라우저에서 **도메인 분할(domain sharding)** 사용 → 한 서버에서 병렬 연결 개수를 제한하므로, 여러 서브 도메인으로 나눠 동시 연결 수를 늘림.
- 하지만 근본 해결은 아니며, 결국 **HTTP/2 → HTTP/3**로 진화하면서 개선됨.

---

## ✅ 면접 대비 용어 정리

- **Persistent Connection(Keep-Alive)**: TCP 연결을 재사용해 여러 요청을 처리하는 방식.
- **HOL Blocking**: 큐에서 첫 요청/응답이 지연되면 뒤의 요청도 함께 지연되는 현상.
- **Heavy Header(무거운 헤더)**: 쿠키, 인증정보 등 반복 전송되는 메타데이터로 인한 오버헤드.

---

## 🔎 면접 꼬리 질문 예상

1. **Q. HTTP/1.0과 HTTP/1.1의 가장 큰 차이는 무엇인가요?**
    - A. HTTP/1.0은 매 요청마다 새로운 TCP 연결을 생성하지만, HTTP/1.1은 Keep-Alive로 연결을 재사용합니다.
2. **Q. HTTP/1.1에서도 왜 여전히 느릴 수 있을까요?**
    - A. 요청/응답을 순차적으로 처리해야 해서 HOL Blocking이 발생하고, 헤더가 압축되지 않아 무거운 문제가 있습니다.
3. **Q. HOL Blocking을 해결하기 위해 나온 기술은 무엇인가요?**
    - A. HTTP/2의 멀티플렉싱(multiplexing)이 대표적인 해결책입니다. 한 TCP 연결 안에서 여러 요청/응답을 독립적으로 처리할 수 있게 합니다.
4. **Q. HTTP/1.1의 무거운 헤더 문제는 어떻게 해결되었나요?**
    - A. HTTP/2에서는 HPACK 압축을 통해 헤더를 줄이고, HTTP/3에서는 QPACK을 사용합니다.

---

👉 요약하면:

HTTP/1.1은 **Keep-Alive**로 TCP 연결 오버헤드를 줄였지만, **HOL Blocking과 무거운 헤더 문제** 때문에 한계가 있어 **HTTP/2와 HTTP/3**로 발전하게 된 단계입니다.