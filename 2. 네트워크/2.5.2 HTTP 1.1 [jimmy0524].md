# 2.5.2 HTTP/1.1

- **한 번 TCP 연결을 열면 Keep-Alive 옵션을 통해 여러 리소스를 송수신**할 수 있도록 개선되었다.
- HTTP/1.0에서도 Keep-Alive가 있었지만 표준화되지 않았으며, **HTTP/1.1부터 기본 옵션으로 표준화**되었다.
- 따라서 **한 번 3-way handshake를 수행하면 이후 요청에는 추가 연결이 필요하지 않음**.

### 장점

- TCP 연결 횟수를 줄여 **RTT 증가 문제 완화**
- 서버 부하와 사용자 응답 시간 감소

### 단점

1. **리소스 수에 비례한 대기 시간**
    - 문서 내 다수의 이미지, 동영상, CSS, JS 파일을 처리할 때, 요청 개수만큼 **대기 시간이 증가**
    - 연결 재사용으로 핸드셰이크 지연은 없지만, 요청-응답 순서에서 발생하는 지연 존재
2. **HOL(Head-of-Line) Blocking**
    - 같은 큐에 있는 패킷 중 첫 번째 패킷 지연 시 **뒤에 있는 패킷도 기다려야 하는 현상**
    - 예: image.jpg 다운로드가 느리면 styles.css, data.xml 등의 다운로드가 지연
3. **무거운 헤더 구조**
    - HTTP/1.1 헤더에는 쿠키 등 메타데이터가 많으며, **압축되지 않아 전송 비용이 큼**

## 📌 면접 예상 질문 & 답변

### 1️⃣ HTTP/1.1에서 HTTP/1.0과 달라진 점은 무엇인가요?

**답변**

HTTP/1.1은 **Persistent Connection(지속 연결, Keep-Alive)**이 기본 동작으로 표준화되었습니다.

즉, 한 번 TCP 연결을 열면 여러 요청과 응답을 처리할 수 있어 **매 요청마다 3-way handshake를 반복하는 문제를 해결**했습니다.

---

### 2️⃣ HTTP/1.1에서 Keep-Alive의 장점은 무엇인가요?

**답변**

- TCP 연결 횟수가 줄어들어 **RTT 증가 문제 완화**
- 서버 부하 감소
- 사용자 응답 속도 개선

---

### 3️⃣ HTTP/1.1의 한계(단점)는 무엇인가요?

**답변**

1. **리소스 수에 비례한 대기 시간** → 다수의 요청이 있을 경우 순차적으로 처리되어 대기 시간이 늘어남
2. **HOL(Head-of-Line) Blocking** → 앞선 요청이 지연되면 뒤 요청들도 함께 지연됨
3. **무거운 헤더 구조** → 쿠키, 메타데이터 등으로 인해 헤더가 크고 압축되지 않아 전송 비용이 큼

---

### 4️⃣ HOL Blocking이란 무엇인가요?

**답변**

HOL(Head-of-Line) Blocking은 **같은 TCP 연결에서 요청-응답이 순차적으로 처리되기 때문에, 앞 요청이 지연되면 뒤 요청도 대기해야 하는 문제**를 말합니다.

예를 들어, image.jpg가 다운로드 중이면 styles.css, data.xml 같은 요청도 기다려야 합니다.

---

### 5️⃣ HTTP/1.1에서 요청을 병렬적으로 처리할 수 있을까요?

**답변**

기본적으로는 불가능합니다.

이를 보완하기 위해 브라우저는 **여러 개의 TCP 연결(보통 6개 내외)**을 열어 병렬 요청을 흉내 냈습니다.

하지만 이는 서버 자원 낭비로 이어져 한계가 있었고, 이후 HTTP/2에서 **Multiplexing**이 도입되었습니다.

---

### 6️⃣ HTTP/1.1의 무거운 헤더 문제는 어떻게 개선되었나요?

**답변**

HTTP/2에서 **헤더 압축(HPACK)**이 도입되어 불필요한 반복 헤더를 효율적으로 줄일 수 있게 되었습니다.

---

### 7️⃣ HTTP/1.1의 HOL Blocking 문제는 어떻게 해결되었나요?

**답변**

HTTP/2에서 **Multiplexing**을 통해 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있게 했습니다.

HTTP/3에서는 TCP 대신 **QUIC(UDP 기반)**을 사용해 전송 계층에서 HOL Blocking 문제를 근본적으로 해결했습니다.