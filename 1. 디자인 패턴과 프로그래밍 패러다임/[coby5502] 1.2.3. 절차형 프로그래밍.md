# 1.2.3 절차형 프로그래밍

### 절차형 프로그래밍

- 로직이 수행되어야 할 연속적인 계산 과정
- 코드의 가독성이 좋으며 실행 속도가 빠르다.
- 모듈화하기 어렵고, 유지 보수성이 떨어진다.

---

## **✅ 절차형 프로그래밍 (Procedural Programming)**

> **“절차(순서)”에 따라 명령을 나열하여 프로그램을 구성하는 방식**
→ 프로그램을 **함수(또는 프로시저)** 중심으로 구성
> 

---

### **📌 핵심 개념**

| **개념** | **설명** |
| --- | --- |
| **중심 구조** | 함수(Function) 또는 프로시저(Procedure) |
| **작성 방식** | 프로그램은 순차적인 명령의 집합 |
| **데이터 중심이 아님** | 데이터와 로직이 분리됨 (OOP와 반대) |
| **코드 흐름** | 위에서 아래로, 조건문과 반복문으로 흐름 제어 |

---

### **✅ 주요 특징**

| **장점** | **단점** |
| --- | --- |
| ✅ 이해하기 쉽고 직관적이다 | ❌ 프로그램 규모가 커질수록 **구조 복잡** |
| ✅ 실행 속도가 빠르다 | ❌ 데이터가 전역으로 공유되면 **버그 유발** |
| ✅ 작은 프로그램에 적합 | ❌ 모듈화가 어려워 **재사용성과 유지보수성 낮음** |
| ✅ 함수로 반복 작업을 줄일 수 있다 | ❌ 기능 중심이라 **관심사 분리가 어려움** |

---

### **✅ 절차형 예시 (C 언어 스타일)**

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    int result = add(x, y);
    printf("%d\n", result);
}
```

- main()이 시작점이고, 순서대로 로직이 흐름
- 모든 데이터가 전역/지역 변수로 존재하며, **데이터 자체가 주체가 되지 않음**

---

### **✅ 객체지향(OOP)와 비교**

| **비교 항목** | **절차형 프로그래밍** | **객체지향 프로그래밍** |
| --- | --- | --- |
| 구조 중심 | **함수 중심** | **객체 중심** |
| 데이터 | 전역/지역 변수 | 객체의 상태와 캡슐화 |
| 설계 방식 | 알고리즘 흐름 설계 | 역할과 책임 기반 모델링 |
| 재사용성 | 낮음 | 높음 |
| 예시 언어 | C, Pascal | Java, C++, Python(OOP 방식) |

---

### **✅ 언제 쓰면 좋은가?**

| **상황** | **이유** |
| --- | --- |
| 시스템 프로그래밍 (운영체제, 드라이버) | 성능 중요, 구조 간단 |
| 간단한 유틸리티 프로그램 | 객체화가 오히려 과할 수 있음 |
| 빠르게 알고리즘 구현 | 로직 중심 구현에 강함 |

---

### **✅ 절차형 vs 선언형 vs 객체지향**

| **구분** | **설명** |
| --- | --- |
| 절차형 | **어떻게 처리할지** 순서대로 명령 |
| 선언형 | **무엇을 할지** 표현 (SQL, React 등) |
| 객체지향 | **데이터와 기능을 객체로 묶어 설계** |

---

## **✅ 요약 정리**

| **항목** | **내용** |
| --- | --- |
| 정의 | 함수와 명령어로 구성된 순차적 실행 기반 프로그래밍 |
| 핵심 단위 | 함수(Procedure) |
| 장점 | 빠르고 직관적이며 구현 쉬움 |
| 단점 | 유지보수 어려움, 재사용성 낮음, 관심사 분리 힘듦 |
| 대표 언어 | C, Pascal 등 |
| 활용 예 | 간단한 유틸리티, 시스템 프로그래밍, 알고리즘 문제 풀이 등 |