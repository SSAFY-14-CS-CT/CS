# 1.1.6 이터레이터(반복자) 패턴

일련의 데이터 집합에 대하여 순차적인 접근을 지원하는 패턴이다.

해시, 트리와 같은 컬렉션은 데이터 저장 순서가 정해지지않고 적재되므로, 어떤 기준으로 접근해야할지 애매함 (깊이 or 너비) - 이러한 자료 컬렉션들을 순회하는 알고리즘 전략을 정의하는 것을 이터레이터 패턴이라고함

추가로 이 패턴은 별도의 객체를 반환 받아 이를 이용해 순회하므로 집합체의 내부 구조를 노출하지 않고 순회 할 수 있다는 장점이 있음

자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

## 장점

- **일관된 인터페이스 제공**

  다양한 자료구조(배열, 리스트, 트리, 해시맵 등)에 대해 동일한 방식으로 순회 가능

- **내부 구조 은폐 (캡슐화)**

  컬렉션의 내부 구조를 감추고, 클라이언트는 순회법에만 집중할 수 있음

- **책임 분리 및 단일책임원칙(SRP) 준수**

  순회 알고리즘을 별도의 반복자 객체로 분리하여, 컬렉션과 순회 책임을 독립적으로 관리 가능

- **확장성 및 유지보수 용이성 (OCP 준수)**

  컬렉션의 종류가 변경되어도 클라이언트 코드를 수정하지 않아도 됨

- **순회 방식의 유연성**

  깊이 우선, 너비 우선 등 다양한 순회 전략을 다른 반복자로 쉽게 구현 가능


## 단점

- **클래스 수 증가**

  반복자 객체가 추가되므로 클래스 수가 늘어나고 설계가 복잡해질 수 있음

- **캡슐화 위배 가능성**

  내부 구조를 너무 드러낼 수 있어, 구현에 따라 캡슐화 원칙이 훼손될 위험 있음


## 실제 활용 예시

`java`
```java
List<String> list = Arrays.asList("A", "B", "C");
Iterator<String> iterator = list.iterator();

while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```
<br>

> 참고 <br>[💠 반복자(Iterator) 패턴 - 완벽 마스터하기](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EB%B0%98%EB%B3%B5%EC%9E%90Iterator-%ED%8C%A8%ED%84%B4-%EC%99%84%EB%B2%BD-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0)
