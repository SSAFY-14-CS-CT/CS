# 1.2.2 객체지향 프로그래밍

### 객체지향 프로그래밍(OOP, Object-Oriented Programming)

- 객체들의 집합으로 프로그램의 상호 작용을 표현
- 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용
- 설계에 많은 시간이 소요, 처리 속도가 느림

### 추상화(abstraction)

- 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것

### 캡슐화(encapspulation)

- 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

### 상속성(inheritance)

- 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장
- 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요

### 다형성(polymorphism)

- 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
- 오버로딩, 오버라이딩

### 오버로딩(overloading)

- 같은 이름을 가진 메서드를 여러개 두는 것
- 메서드의 타입, 매개변수의 유형, 개수 등으로 여러 개를 둘 수 있다.
- 컴파일 중에 발생하는 ‘정적’ 다형성

### 오버라이딩(overriding)

- 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
- 런타임 중에 발생하는 ‘동적’ 다형성

### SOLID 원칙

- 단일 책임 원칙(SRP, Single Responsibility Principle)
    - 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
- 개방-폐쇄 원칙(OCP, Open Closed Principle)
    - 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙
    - 기존 코드는 잘 변경하지 않으면서 확장은 쉽게 할 수 있어야 한다.
- 리스코프 치환 원칙(LSP, Liskov Subsitution Principle)
    - 프로그램의 객체는 프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것
    - 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아간다.
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
    - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
- 의존 역전 원칙(DIP, Dependency Inversion Principle)
    - 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙

---

## **✅ 객체지향 프로그래밍 (OOP, Object-Oriented Programming)**

### **📌 정의**

> 실세계를 모델링하여, 프로그램을 **객체(속성과 기능을 가진 단위)** 중심으로 설계하는 방식
> 

### **📌 특징**

- **객체**: 상태(필드)와 행동(메서드)을 가진 독립 단위
- **클래스**: 객체를 찍어내는 틀
- **설계 중점**: 역할, 책임, 협력

---

## **✅ 핵심 개념 4가지**

### **1. 추상화 (Abstraction)**

> 복잡한 대상에서 **중요한 정보만 추려내어 표현**
> 
- 예: 자동차 객체에서 ‘엔진 ON/OFF’, ‘운전’ 기능만 외부에 제공
    
    → 실제 내부 동작(연료 분사, 전기 회로 등)은 감춤
    
- **목적**: 불필요한 정보 제거, 복잡도 ↓, 설계 명확성 ↑

```java
abstract class Animal {
    abstract void sound(); // 핵심 동작만 정의
}
```

---

### **2. 캡슐화 (Encapsulation)**

> **데이터(필드)와 메서드**를 하나로 묶고, 외부에는 **필요한 기능만 노출**
> 
- **정보 은닉**을 통해 직접 접근을 차단하고, **setter/getter** 등으로 제한된 방식 제공
- 예: private int balance; public void deposit(int amount);

```java
class BankAccount {
    private int balance;

    public void deposit(int amount) {
        if (amount > 0) this.balance += amount;
    }

    public int getBalance() {
        return balance;
    }
}
```

---

### **3. 상속 (Inheritance)**

> **기존 클래스의 속성과 기능을 물려받아 재사용**하거나 **확장**
> 
- **코드 재사용성**, **계층적 구조**, **유지보수 용이**
- is-a 관계 → 예: Cat extends Animal

```java
class Animal {
    void eat() { System.out.println("먹는다"); }
}

class Dog extends Animal {
    void bark() { System.out.println("짖는다"); }
}
```

---

### **4. 다형성 (Polymorphism)**

> 같은 이름의 메서드/클래스가 **다양한 동작**을 수행할 수 있음
> 

### **📍 오버로딩 (Overloading) → 정적(컴파일 타임)**

```java
class Printer {
    void print(String s) {}
    void print(int i) {}
}
```

### **📍 오버라이딩 (Overriding) → 동적(런타임)**

```java
class Animal {
    void sound() { System.out.println("소리"); }
}

class Cat extends Animal {
    void sound() { System.out.println("야옹"); }
}
```

---

## **✅ SOLID 원칙**

### **1. SRP – 단일 책임 원칙**

> 하나의 클래스는 **하나의 책임만** 가져야 한다
> 
- 변경 이유가 하나뿐이어야 함 (ex: 계산하는 클래스 vs 저장하는 클래스 분리)
- 유지보수 용이, 테스트 단순화

```java
class InvoicePrinter {}  // 출력만 담당
class InvoiceSaver {}    // 저장만 담당
```

---

### **2. OCP – 개방-폐쇄 원칙**

> 확장에는 열려 있고 **변경에는 닫혀 있어야 한다**
> 
- 새로운 기능 추가 시 기존 코드를 수정하지 않고 확장
- 인터페이스/추상화 + 전략 패턴, 템플릿 메서드 패턴 등으로 구현

```java
interface DiscountPolicy {
    int apply(int price);
}

class FixDiscount implements DiscountPolicy {
    public int apply(int price) { return price - 1000; }
}
```

---

### **3. LSP – 리스코프 치환 원칙**

> **부모 타입 객체**를 **자식 객체**로 바꿔도 **기능이 깨지지 않아야 한다**
> 
- 잘못된 상속 구조 방지, 대체 가능성 보장

```java
class Bird {
    void fly() {}
}

class Ostrich extends Bird {
    @Override
    void fly() { throw new UnsupportedOperationException(); } // 위반 예시
}
```

✅ 해결: Bird를 FlyingBird, NonFlyingBird로 분리

---

### **4. ISP – 인터페이스 분리 원칙**

> **하나의 큰 인터페이스**보다 **작고 구체적인 인터페이스** 여러 개로 나누어야 한다
> 
- 클라이언트가 자신이 사용하지 않는 기능에 의존하지 않도록 함

```java
interface Printer {
    void print();
}

interface Scanner {
    void scan();
}

// 굳이 scan()을 구현할 필요 없는 클래스 분리 가능
```

---

### **5. DIP – 의존 역전 원칙**

> 고수준 모듈은 저수준 모듈에 의존하면 안 되며, **추상화에 의존**해야 한다.
> 
- 구현이 아닌 **인터페이스에 의존**
- DIP를 구현하려면 보통 **의존성 주입(DI)** 을 사용함

```java
class OrderService {
    private final PaymentProcessor processor;

    public OrderService(PaymentProcessor processor) {
        this.processor = processor;
    }
}
```

---

## **✅ 전체 요약표**

| **개념** | **핵심 요약** |
| --- | --- |
| 추상화 | 핵심 기능만 외부에 제공 |
| 캡슐화 | 정보 은닉 + 인터페이스로만 접근 허용 |
| 상속 | 코드 재사용과 확장 |
| 다형성 | 동일한 메서드 이름 → 다양한 동작 (오버로딩/오버라이딩) |
| SRP | 하나의 클래스 = 하나의 책임 |
| OCP | 확장엔 열려 있고, 변경엔 닫혀야 |
| LSP | 자식은 부모를 대체 가능해야 |
| ISP | 인터페이스는 작고 구체적으로 |
| DIP | 구현 대신 추상화에 의존하라 |

---

## **✅ 정적(Static) vs 동적(Dynamic)**

| **구분** | **정적(Static)** | **동적(Dynamic)** |
| --- | --- | --- |
| 결정 시점 | **컴파일 타임** | **런타임(실행 중)** |
| 의미 | 컴파일 시점에 타입이나 호출 대상이 결정됨 | 실행 중 실제 동작이 결정됨 |
| 예시 | 메서드 오버로딩 | 메서드 오버라이딩 |

---

## **✅ 오버로딩 vs 오버라이딩에서의 차이**

### **🔹 오버로딩 (Overloading) → 정적 바인딩**

```java
class Printer {
    void print(String s) {
        System.out.println("String: " + s);
    }

    void print(int i) {
        System.out.println("int: " + i);
    }
}
```

- print("hello") → String 버전이 **컴파일 시점에 결정**
- 즉, **어떤 메서드를 쓸지는 컴파일할 때 정해짐**

### **🔹 오버라이딩 (Overriding) → 동적 바인딩**

```java
class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Meow");
    }
}

Animal animal = new Cat();
animal.sound(); // 결과: "Meow"
```

- animal은 **Animal 타입이지만 실제 객체는 Cat**
- 어떤 sound()를 호출할지는 **실행 시점(Run time)에 결정됨**

---

## **✅ 비유로 이해해보기**

| **개념** | **비유** |
| --- | --- |
| 정적 바인딩 | **예약된 버스 좌석**: 예약할 때 어떤 좌석에 앉을지 결정됨 |
| 동적 바인딩 | **카카오택시**: 택시는 미리 정해져 있지 않고, 호출하면 그때 상황에 따라 배차됨 |

---

## **✅ 왜 중요할까?**

- 정적 바인딩은 **성능이 좋고 단순**하지만 유연성이 떨어짐
- 동적 바인딩은 **유연하지만 실행 중 오류 가능성 존재**
- 자바의 **다형성(polymorphism)** 은 바로 **동적 바인딩** 덕분에 가능

---

## **✅ 요약**

| **항목** | **오버로딩 (정적 바인딩)** | **오버라이딩 (동적 바인딩)** |
| --- | --- | --- |
| 결정 시점 | 컴파일 타임 | 런타임 |
| 다형성 종류 | 정적 다형성 | 동적 다형성 |
| 메서드 선택 기준 | 매개변수 타입/개수 | 실제 객체 타입 |
| 대표 키워드 | 메서드 이름 같고 시그니처 다름 | 상속 + 메서드 재정의 |