# 3.1 운영체제와 컴퓨터

# **운영체제의 역할 (무엇을 “관리”하나)**

## **1) CPU 스케줄링 & 프로세스 관리**

- **프로세스/스레드 상태**: new → ready → running → (blocked) → ready → terminated
    
    I/O 대기 등으로 **blocked** 되면 CPU를 반납하고, 완료되면 다시 **ready**.
    
- **컨텍스트 스위칭**: 현재 실행 중인 문맥(레지스터/PC/스택포인터 등)을 **PCB/TCB**에 저장하고 다른 작업의 문맥으로 교체. 비용이 있으므로 과도하면 성능 저하.
- **스케줄링 정책**
    - 일반용: **CFS(가상런타임 기반)**, 우선순위/타임슬라이스, **에이징**으로 기아 방지
    - 실시간: **FIFO/RR(고정 우선순위)**, 데드라인 스케줄러
- **프로세스 생성/실행**: fork()(주소공간 복제; **COW**) → exec()(새 프로그램 적재) → wait()(자식 종료 대기)
    - *신호(signals)**로 비동기 이벤트 처리.

## **2) 메모리 관리**

- **가상메모리**: 각 프로세스가 **독립 주소공간** 사용. **MMU**가 가상→물리 변환.
- **페이징**: 고정 크기 **page** 단위 매핑, **page fault** 시 디스크에서 적재.
    - **TLB**(변환 캐시) 미스 많으면 성능 급락 → 지역성/huge page로 완화.
- **할당기**: 커널의 **buddy**(페이지 단위) + **slab/slub**(작은 객체 캐시).
- **공유/매핑**: mmap()으로 파일/익명 메모리를 매핑, 다 프로세스가 같은 페이지를 공유 가능.
- **스와핑**: 메모리 압박 시 냉 페이지를 디스크로 내보냄.

## **3) 디스크/파일 관리**

- **VFS 계층**: POSIX open/read/write 같은 **공통 인터페이스** 위에 ext4/NTFS 등 구현이 붙음.
    - **inode/dentry**로 파일 메타데이터/경로 캐싱, **page cache**로 파일 내용 캐싱.
- **저널링**: 크래시 시 일관성 복구(메타데이터 로그).
- **I/O 스케줄러**: HDD는 시킹 최소화, SSD는 **deadline/noop** 등 단순화. TRIM으로 블록 해제.

## **4) I/O 디바이스 관리**

- **드라이버**: **문자/블록/네트워크** 타입.
- **인터럽트 기반 I/O**: 디바이스가 완료를 알림 → 커널의 **상반부(top half)**가 최소 처리, **하반부(bottom half/softirq)**에서 후속 작업.
- **DMA**: 메모리↔디바이스 **직접 전송**(CPU 개입 최소화).
- **메모리 매핑 I/O**: 디바이스 레지스터를 주소공간에 매핑, 읽기/쓰기로 제어.

---

# **운영체제의 구조 (무엇이 “어디서” 돈다?)**

- **유저 프로그램**: 앱/서비스(브라우저, DB 등). GUI도 보통 **유저 공간**(예: X/Wayland, Windows는 커널·유저 혼합).
- **GUI**: 입력/창/컴포지팅을 제공하는 **유저 공간 서버**(플랫폼 따라 다름).
- **시스템콜**: 유저 공간→커널 공간 **진입점**(아래에서 자세히).
- **커널**: 프로세스/메모리/파일/네트워크/I/O 전권.
    - **모놀리식**(Linux) vs **마이크로커널**(드라이버·서비스를 유저로 분리, 예: seL4) vs **하이브리드**(Windows, XNU).
- **드라이버**: 보통 커널 모듈(속도/권한)이나 일부 OS는 유저 공간 드라이버도 지원.
- **하드웨어**: CPU, 메모리, 디스크/SSD, NIC, GPU 등. **IOMMU**가 DMA 접근을 가상화/격리.

**흐름(파일 읽기 예)**

read() 호출(유저) → 시스템콜 진입 → VFS가 파일 디스크립터 resolve → 캐시 히트면 복사 → 미스면 블록 I/O 발행(DMA) → 데이터 도착 인터럽트 → 커널이 복사 후 반환.

---

# **시스템콜 (유저→커널 “문”)**

- **정의**: 유저 프로그램이 커널 서비스를 쓰는 **공식 인터페이스/ABI**. 표준 API(libc)는 **래퍼**일 뿐.
- **진입 방법**: 아키텍처 별 **트랩 명령** 사용
    - x86-64: syscall/sysret, sysenter/sysexit
    - AArch64: svc #imm
    - RISC-V: ecall
- **수행 단계**
    1. 유저 코드가 libc를 통해 **시스템콜 넘버 + 인자** 준비
    2. **트랩** → CPU가 **모드비트** 전환(유저→커널) & 커널 스택/페이지테이블로 스위칭
    3. 커널이 **권한/포인터 검증**(예: copy_from_user) 후 실제 핸들러(sys_read) 실행
    4. 필요 시 **블록**(I/O 대기) → 스케줄러가 다른 태스크로 전환
    5. 완료되면 값/errno 세팅 후 **커널→유저** 복귀
- **특징**
    - **추상화 계층**이 맞다. 하드웨어·보안·동기화 디테일을 숨겨 **일관된 인터페이스** 제공.
        
        (DB는 커널이 아니고 **유저 공간** 소프트웨어지만, 시스템콜 덕에 파일/네트워크를 안전·일관되게 사용.)
        
    - **비용**: 모드 전환 + 검증 + 컨텍스트 관리. 잦은 호출은 비용 큼 → **배치/벡터링**, **mmap**, **io_uring** 같은 최적화 활용.
    - **vDSO**: gettimeofday 같은 일부 호출을 **유저 공간**에서 빠르게 제공(완전 커널 진입 회피).

**대표 시스템콜**: open/read/write/close, socket/connect/send/recv, fork/exec/wait, mmap/munmap, ioctl, clone, futex.

---

# **mode bit (권한 레벨 스위치)**

- **무엇?** CPU의 **특권 레벨 플래그**. 커널만 실행 가능한 **특권 명령**(페이지테이블 변경, I/O 포트 접근 등)을 보호.
    - 단순화하면: 0 = 커널 모드, 1 = 유저 모드 (표기 관례는 아키텍처마다 다름)
    - 실제로는 레벨이 더 세분: **x86 링 0~3**, **ARM EL0/EL1(EL2=하이퍼바이저)**, **RISC-V U/S/M** 등.
- **어디에 저장?** CPU의 **상태 레지스터/프로그램 상태 워드(PSW/CSR)**에 포함. **코어별 상태**이며 전역 변수 같은 게 아님.
- **전환 시점**
    - **유저→커널**: 시스템콜, **예외**(0 나누기 등), **인터럽트** 발생 시 자동 전환.
    - **커널→유저**: sysret/eret 등 복귀 명령으로 돌아감.
- **보안/격리**
    - 유저 모드에서는 커널 메모리/특권 명령 접근 불가(페이지 권한 + SMEP/SMAP 같은 하드닝).
    - 취약점 완화: KPTI(멜트다운 완화)로 유저/커널 페이지테이블 분리 등.
- **면접 포인트**: **모드 전환(mode switch)** ≠ **컨텍스트 스위치(context switch)**
    - 모드 전환은 **같은 태스크**가 유저↔커널로 드나드는 것.
    - 컨텍스트 스위치는 **태스크 교체**(레지스터/주소공간까지 바뀜). 서로 독립적이며 함께 일어날 수도, 따로 일어날 수도 있음.

---

# **미니 예시로 보는 호출 경로**

**파일 읽기 (C, 개념 흐름)**

```
int fd = open("a.txt", O_RDONLY);   // libc → syscall → VFS → inode 찾기
char buf[4096];
ssize_t n = read(fd, buf, sizeof(buf)); // 페이지캐시 히트? 바로 복사
                                       // 미스? 블록 I/O 제출(DMA), 인터럽트 후 복귀
close(fd);
```

**프로세스 실행**

```
parent: pid = fork()            // COW로 주소공간 공유 시작
child:  execve("/bin/ls", ...)  // 새 ELF 적재, 이전 코드/데이터 교체
parent: waitpid(pid, ...)       // 자식 종료/상태 수집
```

---

# **요약 키워드(면접·필기용)**

- **프로세스 상태/PCB, 컨텍스트 스위치 비용, CFS/RT 스케줄링**
- **가상메모리, TLB, 페이지폴트, COW, slab/buddy, mmap**
- **VFS, inode/dentry, 페이지캐시, 저널링, I/O 스케줄러**
- **드라이버/인터럽트(상·하반부), DMA, MMIO**
- **시스템콜 경로, 트랩, 포인터 검증, 블로킹/논블로킹, vDSO, io_uring**
- **mode bit(특권 레벨), 모드 전환 vs 컨텍스트 스위치, 보안 격리**

---

### CPU(Central Processing Unit)

- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼

### 제어장치(CU, Control Unit)

- 프로세스 조작을 지시하는 CPU의 한 부품
- 입출력장치 가나 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정

### 레지스터

- CPU 안에 있는 매우 빠른 임시기억장치

### 산술논리연산장치(ALU, Arithmetic Logic Unit)

- 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로

### 인터럽트

- 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것
- 인터럽트가 발생되면 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행된다.
- 인터럽트 간에는 우선순위가 있고 우선순위에 따라 실행되며 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트 두 가지로 나뉜다.

### 하드웨어 인터럽트

- 키보드를 연결한다거나 마우스를 연결하는 일 드의 IO 디바이스에서 발생하는 인터럽트
- 인터럽트 라인이 설계된 이후 순차적인 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근

### 소프트웨어 인터럽트

- 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동

### DMA 컨트롤러

- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주며 CPU의 일을 부담하는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지

### 메모리

- 데이터나 상태, 명령어 등을 기록하는 장치
- RAM을 일컬어 메모리
- CPU는 계산을 담당하고, 메모리는 기억을 담당
- CPU는 일꾼, 메모리는 작업장, 작업장의 크기
- 작업장이 클수록 창고에서 물건을 많이 가져다놓고 많은 일을 할 수 있듯이 메모리가 크면 클수록 많은 일을 동시에 할 수 있다.

### 타이머

- 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할
- 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재

### 디바이스 컨트롤러(device controller)

- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU를 말하고 옆에 붙어 있는 로컬 버퍼는 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리
