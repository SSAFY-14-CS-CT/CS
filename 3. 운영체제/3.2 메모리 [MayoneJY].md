## 🔹 메모리 계층

* **레지스터 → L1/L2/L3 캐시 → 메모리(RAM) → 저장장치** 순으로 용량은 커지고 속도는 느려집니다.
* CPU는 ‘메모리에 올라온’ 명령어만 실행합니다. 계층 구조 이해가 성능의 기본입니다.

## 🔹 가상 메모리·MMU·TLB

* **가상 메모리**: 실제 RAM보다 큰 메모리를 쓰는 것처럼 보이게 하는 기법.
* **가상 주소 ↔ 물리 주소**는 **페이지 테이블**로 매핑되며, 변환은 **MMU**가 담당합니다.
* **TLB**: 주소 변환 결과를 캐싱하는 계층으로, 페이지 테이블 접근 없이 빠른 변환을 돕습니다.

### 🔹 페이지/프레임 용어

* **페이지(Page)**: 가상 메모리의 최소 단위
* **프레임(Frame)**: 물리 메모리의 최소 단위

## 🔹 페이지 폴트·스와핑·스레싱

1. **페이지 폴트**: 가상 주소는 있으나 RAM에 해당 페이지가 없을 때 발생

   * CPU 트랩 → OS가 페이지 테이블·빈 프레임 확인 → 필요 시 **스와핑**으로 디스크에서 로드 → 재개
2. **스와핑**: 덜 쓰는 페이지를 디스크로 내리고 필요한 페이지를 RAM으로 불러옴
3. **스레싱**: 과도한 페이지 폴트·스와핑으로 성능 급락

   * **작업 집합(Working Set)**: 최근 참조 지역성에 기반해 필요한 페이지 집합을 미리 메모리에 로드
   * **PFF(Page Fault Frequency)**: 상·하한선을 두고 폴트율이 높으면 프레임 증가, 낮으면 감소

## 🔹 메모리 할당 기법

### 1) 연속 할당(Contiguous)

* **고정 분할**: 미리 분할 → **내부 단편화** 위험
* **가변 분할**: 프로그램 크기에 맞춰 동적 분할 → **외부 단편화**(홀) 발생
* 탐색 전략: **First Fit / Best Fit / Worst Fit**

### 2) 불연속 할당(Non-contiguous)

* **페이징**: 고정 크기 페이지 단위로 나눠 외부 단편화 제거, 주소 변환 오버헤드 존재
* **세그멘테이션**: 코드/데이터/스택 등 의미 단위로 분할(공유·보안 강점, 외부 단편화 단점)
* **페이지드 세그멘테이션**: 두 방식 결합 — 의미 단위 유지 + 페이지 단위 관리

## 🔹 페이지 교체 알고리즘

* **오프라인(Optimal)**: 앞으로 가장 늦게 쓰일 페이지를 교체(비현실적, 상한선 지표)
* **FIFO**: 먼저 들어온 페이지부터 교체(간단하지만 Belady 현상 가능)
* **LRU**: 가장 오래 참조되지 않은 페이지 교체(스택·카운터 필요 → 구현 비용 큼)

  * 실무 구현 팁: **연결 리스트 + 해시**(LRU Cache)로 O(1) 접근/교체
* **NUR(Clock)**: 참조 비트(0/1)를 둬 시계 바늘이 0을 만나면 교체, 이후 비트 갱신
* **LFU**: 참조 횟수가 가장 적은 페이지 교체(콜드 페이지 편향 주의)

---

## 🔹 면접 대비 포인트

* TLB 미스/히트가 실제 지연에 미치는 영향 설명
* 스레싱 발생 시 운영체제/시스템 차원의 대응(작업 집합, PFF, 메모리 증설)
* 연속/불연속 할당의 **단편화** 유형과 해결 전략

## 🔹 실제 면접관 시각의 질문 & 답변

### 1) 페이징과 세그멘테이션의 차이를 설명해보세요.

**답변**: 페이징은 고정 크기 단위로 나눠 **외부 단편화**를 줄이지만 의미 단위가 사라져 주소 변환 오버헤드가 큽니다. 세그멘테이션은 의미 단위 분할로 **공유·보안**에 유리하나 **외부 단편화**가 발생합니다. 페이지드 세그멘테이션은 장점을 결합합니다.

### 2) LRU가 이상적인데 왜 항상 쓰지 않나요?

**답변**: 참조 시각을 추적하려면 스택/카운터 등 **메타데이터 관리 비용**이 큽니다. 그래서 하드웨어 지원 없이는 LRU 근사(NUR/Clock)나 계층형 캐시 정책을 씁니다.

### 3) 스레싱이 발생했습니다. 어떤 조치를 하겠습니까?

**답변**: (OS 정책) **PFF 상·하한**으로 프레임 재할당, **작업 집합** 선로딩. (시스템) 물리 메모리 증설, SSD 전환. (애플리케이션) 메모리 지역성 개선, 배치/캐시 전략 재설계.
